---
layout:     post
title:      防暴力登录想法及实现
subtitle:   api流量限流，防暴力登录，api调用权限设置
date:       2018-01-19
author:     yxp
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - api流量限流
    - 防暴力登录
    - api调用权限设置
---

>防暴力登录想法及Java实现


#  在开发接口服务器的过程中，为了防止客户端对于接口的滥用，保护服务器的资源， 通常来说我们会对于服务器上的各种接口进行调用次数的限制。比如对于某个 用户，他在一个时间段（interval）内，比如 30 分钟内，调用服务器接口的次数不能够 大于一个上限（limit），比如说 30 次。如果用户调用接口的次数超过上限的话，就 直接拒绝用户的请求，返回错误信息。
下面我们来进行实战解析：
##  如果你的系统登录接口被暴力破解，我们需要建立一个防刷机制。根据请求的源ip。30分钟之内，允许最多请求30次，如果超过这限制，则该ip被限制登录30分钟。
###  首先分析这个题目，可能首先想到的做法是以ip为key，尝试登录次数为value，最后登录时间+30min为失效时间，记录在缓存中
###  这种实现方法，仔细想来，存在多个缺陷：
1. 时间的连续性，比如某个ip，在第一分钟登录了28次，第29分钟时登录了1次，那么根据题目的要求第30分钟应该可以允许登录28次而不会被记录到黑名单中，但是此情况只记录了最后的登录时间+interval为失效时间，忽略了时间的连续性。
2. 缓存被击穿，比如缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB（或直接根据key值拉取登录次数）加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB（或redis）压垮。
> 
初步解决方案
1、 使用token bucket算法
算法的思想初步实现方式大概为
1. 所有的登录请求在放行之前需要获取一定量的 token；
2. 所有的 token 存放在一个 bucket（桶）当中，每 60  秒，都会往这个 bucket 当中加入一个 token；
3. bucket 有最大容量（capacity or limit），在 bucket 中的 token 数量等于最大容量，而且没有 token 消耗时，新的额外的 token 会被抛弃。
简单来看，可以将这个算法类比成有个水龙头在往水桶中放水，然后不断地有水瓢到这个水桶中打水去浇花，如果水桶的水满了，那么 水就从水桶中溢出了。初步的想法很简单，对于每个bucket设置一个定时器，每隔一段时间就往这bucket里加入一些token，每个ip获取一个token后，将bucket中的token数量减一。然而，稍微考虑一下这个方案是行不通的，原因是一个定时器一个线程，那么实际项目中这个线程数量是和真实ip数量级一致的，几万个线程运行在服务器上，想想都是可怕的。。
所以这种想法被pass掉了。
